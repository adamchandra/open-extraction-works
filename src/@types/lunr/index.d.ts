/** Declaration file generated by dts-gen */

/// <reference types="node" />


declare function lunr(config: any): any;

declare namespace lunr {
    class Builder {
        constructor();

        add(doc: any, attributes: any): void;

        b(number: any): void;

        build(): any;

        calculateAverageFieldLengths(): void;

        createFieldVectors(): void;

        createTokenSet(): void;

        field(fieldName: any, attributes: any): void;

        k1(number: any): void;

        ref(ref: any): void;

        use(fn: any, ...args: any[]): void;

    }

    class FieldRef {
        constructor(docRef: any, fieldName: any, stringValue: any);

        toString(): any;

        static fromString(s: any): any;

        static joiner: string;

    }

    export class Index {

  // this.invertedIndex = attrs.invertedIndex
  // this.fieldVectors = attrs.fieldVectors
  // this.tokenSet = attrs.tokenSet
  // this.fields = attrs.fields
  // this.pipeline = attrs.pipeline




        constructor(attrs: any);

        query(fn: any): any;

        search(queryString: any): any;

        toJSON(): any;

        static load(serializedIndex: any): any;

    }

    class MatchData {
        constructor(term: any, field: any, metadata: any);

        add(term: any, field: any, metadata: any): void;

        combine(otherMatchData: any): void;

    }

    class Pipeline {
        constructor();

        add(...args: any[]): void;

        after(existingFn: any, newFn: any): void;

        before(existingFn: any, newFn: any): void;

        remove(fn: any): void;

        reset(): void;

        run(tokens: any): any;

        runString(str: any, metadata: any): any;

        toJSON(): any;

        static load(serialised: any): any;

        static registerFunction(fn: any, label: any): void;

        static warnIfFunctionNotRegistered(fn: any): void;

    }

    class Query {
        constructor(allFields: any);

        clause(clause: any): any;

        isNegated(): any;

        term(term: any, options: any): any;

        static presence: {
            OPTIONAL: number;
            PROHIBITED: number;
            REQUIRED: number;
        };

    }

    class QueryLexer {
        constructor(str: any);

        acceptDigitRun(): void;

        backup(): void;

        emit(type: any): void;

        escapeCharacter(): void;

        ignore(): void;

        more(): any;

        next(): any;

        run(): void;

        sliceString(): any;

        width(): any;

        static BOOST: string;

        static EDIT_DISTANCE: string;

        static EOS: string;

        static FIELD: string;

        static PRESENCE: string;

        static TERM: string;

        static lexBoost(lexer: any): any;

        static lexEOS(lexer: any): void;

        static lexEditDistance(lexer: any): any;

        static lexField(lexer: any): any;

        static lexTerm(lexer: any): any;

        static lexText(lexer: any): any;

        static termSeparator: RegExp;

    }

    class QueryParser {
        constructor(str: any, query: any);

        consumeLexeme(): any;

        nextClause(): void;

        parse(): any;

        peekLexeme(): any;

        static parseBoost(parser: any): any;

        static parseClause(parser: any): any;

        static parseEditDistance(parser: any): any;

        static parseField(parser: any): any;

        static parsePresence(parser: any): any;

        static parseTerm(parser: any): any;

    }

    class Set {
        constructor(elements: any);

        contains(object: any): any;

        intersect(other: any): any;

        union(other: any): any;

    }

    class Token {
        constructor(str: any, metadata: any);

        clone(fn: any): any;

        toString(): any;

        update(fn: any): any;

    }

    class TokenSet {
        constructor();

        intersect(b: any): any;

        toArray(): any;

        toString(): any;

        static fromArray(arr: any): any;

        static fromClause(clause: any): any;

        static fromFuzzyString(str: any, editDistance: any): any;

        static fromString(str: any): any;

    }

    class Vector {
        constructor(elements: any);

        dot(otherVector: any): any;

        insert(insertIdx: any, val: any): void;

        magnitude(): any;

        positionForIndex(index: any): any;

        similarity(otherVector: any): any;

        toArray(): any;

        toJSON(): any;

        upsert(insertIdx: any, val: any, fn: any): void;

    }


    const version: string;

    function QueryParseError(message: any, start: any, end: any): void;

    function generateStopWordFilter(stopWords: any): any;

    function idf(posting: any, documentCount: any): any;

    function stemmer(token: any): any;

    function stopWordFilter(token: any): any;

    function tokenizer(obj: any, metadata: any): any;

    function trimmer(token: any): any;

}

declare module 'lunr' {
    export class Index {

        // this.invertedIndex = attrs.invertedIndex
        // this.fieldVectors = attrs.fieldVectors
        // this.tokenSet = attrs.tokenSet
        // this.fields = attrs.fields
        // this.pipeline = attrs.pipeline




        constructor(attrs: any);

        query(fn: any): any;

        search(queryString: any): any;

        toJSON(): any;

        static load(serializedIndex: any): any;

    }

    namespace Index {
    }
}
